
Now let's put together everything we have learned this week.
We are going to write a moderately long Haskell program, 
consisting of multiple functions and I/O actions.

## Guessing Game

The program is going to be a guessing game, called Starman.
In this single-player, text-based game, there is a word
which the player needs to guess. For each turn of the game,
the player guesses a single letter. If that letter is correct,
then the guessed letters are displayed in the correct place
in the word. If that letter is incorrect, then the user collects
a star. Once the user has too many stars, they have lost the game.
However if the user guesses all the letters int he word, they have
won the game.

Because this game is quite long, let's use a texteditor 
(like Notepad++ on Windows, TextEdit on Mac or Gedit on Linux) 
[well, I actually use emacs...]
Create a file called starman.hs - the hs extension is to indicate 
that this file contains Haskell source code.

### Key Functions

The heart of the game involves checking the player's guess.
We want to know whether the guess was right. 
This outcome is a Bool value, either True or False.
We need to update the displayed word, 
if the guess was right, by replacing each 
underscore where the guessed character appears. 
Therefore the result type of the function is a pair (Bool, String). 

Now, the checking function needs to know:
* The secret word :: String.
* The current display :: String.
* The c::Char character guessed by the player.
These are the inputs to the checking function.
So now we can state the type of the function:

~~~ haskell
check :: String -> String -> Char -> (Bool,String)
~~~

**Programming tip**: It's always helpful to work out the 
*type* of a function first. 
This focuses your attention on what the function 
is supposed to compute, and what data it needs to do it. 
Only after you know what the function is supposed to do, 
should you start implementing it.
Good software engineers do specification before implementation.

What will the check function body look like?

The player's guess is correct if and only if 
the guessed character c is in the target word.
* Guess is right if c `elem` word 
The new display is
* [(if x==c then c else y) | (x,y) <- zip word display]]
a list comprehension. Select letter from either the word or
the display - the word is plaintext - the display starts ------ all 
hyphens.

~~~ haskell
check :: String -> String -> Char -> (Bool, String)
check word display c
  = (c ‘elem‘ word, [
      if x==c
          then c
          else y | (x,y) <- zip word display
          ])
~~~ 

The next function we will define is the turn
function. This is the function that will be called
each time it is the player's turn to enter a guess.
First we need to check how many guesses the player has left.
* if n== 0
Then we need to see whether the player is correct or not ...
* if word == display

two if checks - followed by putStrLn status messages and end of 
function (really, end of game).
if the player can take a turn, call the
??? function - move, input. function?

~~~ haskell
move :: String -> String -> Int -> IO ()
move word display n =
  do if n==0
       then putStrLn "You lose"
       else if word==display
              then putStrLn "You win!"
              else userguess word display n
~~~ 

(Is there a neater way to do this, perhaps using guards?)

... yes but we don't learn about them till week 3!


userguess word display n =
  do putStrLn (display ++ "  " ++ take n (repeat '*'))
     putStr "  Enter your guess: "
     q <- getChar
     putStrLn ""
     let (correct, display') = check word display q
     let n' = if correct then n else n-1
     move word display' n'



what is the type of userguess? add it to the definition...

Note that this uses getChar instead of getLine - returns a single character of input rather than a String
Notice the use of repeat to build a list of many * characters, and take to grab the first n elements of this list. 



OK - so now we just need a top-level function, let's call this
starman

starman :: String -> Int -> IO ()
starman word n = move word ['_' | x <- word] n

This function takes two arguments, the first is the word to be 
guessed, and the second is the number of incorrect guesses the
player is allowed.



### Running the Code

OK. Let's put all these four functions into
a textfile, called starman.hs

Save them - then start ghci
- perhaps by typing ghci into a DOS command prompt, running WinGHCi
or typing GHCi in a terminal window (macOS or Linux).

If you are in the correct directory - i.e. the one where you saved 
starman.hs, you should be able to say

    :l starman.hs

and the program should load. It will either say:

    OK

or report an error if you have made a mistake in the
source code anywhere. Check and make corrections if necessary.

Now, to run the program, at the ghci prompt type

    starman "atrocious" 5

and start playing the game!
You will return to the GHCi prompt when the starman function completes.


We have provided the Haskell source code for starman.hs as a download below, along with some comments. You could use this - but it
would be better to type in the program yourself and try to
understand it.

### Possible Extensions

A real improvement to the game would be to generate a random word, perhaps from a list of words or a dictionary file.
If you are feeling ambitious, you might try this. 
It would involve generating a random number i and read in the ith word from a dictionary. import System.Random and use the random number
generator - some links?


