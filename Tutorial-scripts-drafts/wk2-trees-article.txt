In Computer Science, trees grow upside down. The unique root  
is at the top, and the leaves are at the bottom. 

The binary tree data type is often used for
storing data in a sorted order, to allow efficient
searching.
(example!)

We are going to define a Haskell data type for trees, storing integer values.

data Tree = Leaf | Node Int Tree Tree deriving Show

recursive data type!
Node - compound element - stores an Int payload and has branches to two subtrees (children)

Here is the simplest tree - just a single leaf.

Leaf

Here is a tree with one Node containing value 3, and two leaves.

Node 3 Leaf Leaf

If you type this into ghci, you will see the values returned when you construct
these trees- so long as your Tree datatype derives the Show type class.

Look at the type of the values let l = Node 3 Leaf Leaf
:t l

Look at the type of the constructor Node

:t Node

It is a function - for instance Node takes 3 arguments and returns a Tree (object?)


Right, now let's write a function to compute the depth of a tree - this is the maximum number of branches
from the root to any leaf.
To write this function, we are going to pattern match on the different kinds of Tree - Leaves and Nodes - then
for Nodes, we are going to recursively process the two child Trees.

let treeDepth Leaf = 0
     treeDepth Node _ leftSubtree rightSubtree = 1 + max (treeDepth leftSubtree) (treeDepth rightSubtree)

and you can imagine how to write a very similar function that traverses a tree and adds up all the values in
its nodes. Have a go at writing this - call it treeSum

here is its type

treeSum :: Tree -> Int

How about a function to check whether a tree is sorted properly? The invariant we want is
that for any Node storing value x, all values in its left subtree are <= x, and all values in its right
subtree are > x.

So this function will take in a Tree, a minval, a maxval and return a Bool.
isSortedTree :: Tree -> Int -> Int -> Bool

A Leaf is automatically sorted - no values
 - node check values in it are between the max and the min value - which start off as big as possible, then get split into two ranges based on the value at each node
isSortedTree :: Tree -> Int -> Int -> Bool
isSortedTree Leaf minVal maxVal = minVal <= maxVal -- or True?
isSortedTree (Node x leftSubtree rightSubtree) minVal maxVal =
    let leftSorted = isSortedTree leftSubtree minVal x
        rightSorted = isSortedTree rightSubtree x maxVal
    in x > minVal && x<= maxVal && leftSorted && rightSorted

You can download this Haskell source code below - sortedtree.hs - and load it
into your ghci as follows
:l sortedtree.hs

(assuming it is in right directory)

then invoke the function from the ghci prompt

isSortedTree (Node 2 (Node 1 Leaf Leaf) (Node 3 Leaf Leaf)) minBound maxBound

minBound is the smallest possible integer value, maxBound is the largest.

Let's look at one more function for now ...
so far, we have studied tree traversal functions - where we go through the tree data structure and do some
incremental computation at each node.
Now we want to make a tree modification function - it generates a new tree (functional data structures!) that is a modified version of the input tree.

The particular function we are going to define inserts a new maximum value... - we keep going until we find the rightmost node with a leaf on the right - then replace this rightmost leaf with a new node with  a new max value (one larger than previous max value).


addNewMax :: Tree -> Tree
-- add a new max element to tree
addNewMax Leaf = Node 0 Leaf Leaf  -- input tree with no nodes
addNewMax (Node x t1 Leaf) = Node x t1 (Node (x+1) Leaf Leaf)  -- this is the rightmost Node
addNewMax (Node x t1 t2) = Node x t1 (addNewMax t2) -- intermediate node, go down right subtree

so the function takes a Tree input value and returns a Tree output value.
You can download this code from addnewmax.hs below, and load it into ghci.
Note this is not a destructive update - the old 'tree' - the input - is still there - unchanged. We have created a new data structure - some nodes shared... google purely functional data structures for more info. 


Right. Now you need to write some Tree functions yourself. Download the trees.hs program below and load it into ghci. In the following exercise we are going to look at inserting values into a tree in order, and turning a tree into a list.

